---
title: "Machine learning 2"
author: "Mara Acuja"
date: "24 11 2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# librarys

```{r import_libs, include=TRUE}
#install.packages("ggmap")
#install.packages("maptools")
#install.packages("maps")
#install.packages("glmnet")
#install.packages("ISLR")
#TODO the one below necessary?
#install.packages("rgl")

library(glmnet)
library("ggplot2")
library("ggmap")
library("maptools")
library("maps")

library(ISLR)
options(rgl.printRglwidget = TRUE)
library(rgl)

```

# Comparison of machine learning algorithms / Introduction / Theory

This report attempts to compare two regression/classification algorithms on its behaviour on a specific data set. What should be found out?
This report attempts to compare two regression/classification algorithms on its behavior on a specific data set. What should be found out?


# Data set
Here should be a bit of a short summary of the data set with some key characteristics of the data set.

What is it about? Which variables are included? What type of variables?
What is missing? What about missing values?

```{r functions, include=TRUE}
distances <- function(predicted, actual_value) {
  dif <- predicted-actual_value
  dif <- dif * (40030/360) # scaling coordinates to km by the factor circumference (km) / 360Â°
  mse <- sqrt(dif[,1]^2 + dif[,2]^2)
  return(mse)
}
```

```{r import_files, include=TRUE}
data <- read.csv("Data/default_plus_chromatic_features_1059_tracks.txt", header=FALSE)
data <- as.data.frame(data)
colnames(data)[117:118] <- c("Latitude", "Longitude")
```

```{r preprocessing, include=TRUE}
# Maybe some more preprocessing could be done here.
anyNA(data) # testing if there is at least a single NA -> but in this dataset there isn't
# Maybe some more pre-processing could be done here.
anyNA(data) # testing if there is at least a single NA -> but in this data set there isn't
anyDuplicated(data) # testing for duplicates -> 0 found
```

```{r insights, include=TRUE}
# basic world map with music origins
mapWorld <- borders("world", colour="gray50", fill="white")
mp <- ggplot() + mapWorld
# TODO: @Stefan: I changed the line below from (x=Latitude, y=Longitude) to that one. The points didnt match with the world. Now they do.
mp + geom_point(data = data, aes(x = Longitude, y = Latitude), color = "red", alpha = 0.5)
```

```{r split_into_test_and_train, include=TRUE}
set.seed(1)
n <-dim(data)[1]
train <- sample(1:n, 0.8*n)
test <- (1:n)[-train]
```



# Method
Short summary about the algorithms. Which are used? What do we do? Classification or Regression?

## Algorithm 1 - Linear Regression

Short introduction of the first algorithm. What does it do? What are the strengths? What are weaknesses? How is it implemented, including major code snippets.

```{r linear_regression, include=TRUE}
model.lm.all <- lm(cbind(Longitude, Latitude)~., data=data[train,])
#summary(model.lm.all)

# for a significance level of <0.05: just the variables fitting this constraint are taken.
model.lm.sig <- lm(cbind(Longitude, Latitude)~ V4+V9+V16+V30+V32+V33+V37+V38+V61+V90+V91+V92+V95+V96+V104+V5+V6+V8+V9+V11+V15+V34+V39+V63+V94+V97, data=data[train,])

anova(model.lm.all, model.lm.sig)

pred <- predict(model.lm.sig, newdata=data[test,])
mean(distances(pred, data[test, c("Latitude","Longitude")])) ## final result in km
# TODO:  in GGPLOT2
boxplot(distances(pred, data[test, c("Latitude","Longitude")])) 
```

```{r Matthias_playground_ridge, include=TRUE}
grid <- 10^seq(10, -2, length=100)
x <- model.matrix(cbind(Longitude, Latitude)~., data)[,1:116]
y <- data[, c("Latitude","Longitude")]
#set.seed(100)


## This is code for the evalutation how lambda for the models differ depending on the output variable (Latitude vs. Longitude)

#outputs <- matrix(nrow=100, ncol=2)
#for (r in 1:100) {
#  out1 <- cv.glmnet(x[train,], y[train,1], alpha=0)
#  #plot(out1)
#  bestlam <- out1$lambda.min
#  outputs[r,1] <- bestlam
#  out2 <- cv.glmnet(x[train,], y[train,2], alpha=0)
#  #plot(out2)
#  bestlam <- out2$lambda.min
#  outputs[r,2] <- bestlam
#}

#xx <- outputs[,1]
#yy <- outputs[,2]
#t.test(xx,yy)
#boxplot(outputs)

# Ridge regression with cross-validation depending on tw separate models
ridge.mod.1 <- cv.glmnet(x[train,], y[train,1], alpha=0)
plot(ridge.mod.1)
bestlam1 <- ridge.mod.1$lambda.min

ridge.mod.2 <- cv.glmnet(x[train,], y[train,2], alpha=0)
plot(ridge.mod.2)
bestlam2 <- ridge.mod.2$lambda.min

# predictions for two separate models
pred1 <- predict(ridge.mod.1, s=bestlam1, newx=x[test,])
pred2 <- predict(ridge.mod.2, s=bestlam2, newx=x[test,])

pred <- cbind(pred1, pred2)
mean(distances(pred, data[test, c("Latitude","Longitude")])) ## final result in km

# predictions for a model using just one lambda (mean)
pred1 <- predict(ridge.mod.1, s=(bestlam1+bestlam2)/2, newx=x[test,])
pred2 <- predict(ridge.mod.2, s=(bestlam1+bestlam2)/2, newx=x[test,])


pred <- cbind(pred1, pred2)
mean(distances(pred, data[test, c("Latitude","Longitude")])) ## final result in km

```


## Algorithm 2
Short introduction of the second algorithm. What does it do? What are the strengths? What are weaknesses? How is it implemented, including major code snippets.


# Results
Here some tables, summaries or especially graphs should be shown here. Maybe this section should be separated into two to show the algorithms for themselves


# Discussion
Here follows the discussion of the results. What are the major findings? How did the algorithms perform? Which one was better overall? Is it always better or were the findings which were better by the other one?
Which one should be implemented? How could the algorithm be tweeked to perform even better?
Where were the problems during implementation? Where are the limits for the algorithms?

How precise do we predict the cities? How far is the difference in kilometres? The authors of the paper where the dataset comes from have a mean great circle error of 3113km? Are we above or below and by how much?


# Conclusion
At final some conclusions about the key findings and which algorithm should be used. What was the goal? Were and how were they achieved?

# RMarkdown default stuff - needs to be removed but serves up to now as draft

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
